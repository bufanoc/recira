<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>VXLAN Web Controller</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Dojo Toolkit -->
    <link rel="stylesheet" href="dojo/resources/dojo.css">
    <link rel="stylesheet" href="dijit/themes/claro/claro.css">
    <link rel="stylesheet" href="dojox/grid/resources/Grid.css">
    <link rel="stylesheet" href="dojox/grid/resources/claroGrid.css">

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 24px;
            color: #333;
        }

        #app-container {
            display: none;
            width: 100%;
            height: 100vh;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 15px 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 300;
        }

        .header .subtitle {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }

        .content {
            padding: 30px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .stat {
            font-size: 36px;
            font-weight: bold;
            color: #3498db;
            margin: 20px 0;
        }

        .label {
            color: #7f8c8d;
            font-size: 14px;
        }

        .success { color: #27ae60; }
        .warning { color: #f39c12; }
        .info { color: #3498db; }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }

        .btn:hover {
            background: #2980b9;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-badge.online {
            background: #d4edda;
            color: #155724;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }

        tr:hover {
            background: #f8f9fa;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
        }

        .modal-content {
            background: white;
            margin: 10% auto;
            padding: 30px;
            border-radius: 8px;
            width: 500px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .modal-header {
            font-size: 24px;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .btn-primary {
            background: #27ae60;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }

        .btn-primary:hover {
            background: #229954;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        /* Topology Visualization Styles */
        .topology-container {
            position: relative;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            border-radius: 12px;
            overflow: hidden;
            min-height: 500px;
        }

        .topology-header {
            position: absolute;
            top: 15px;
            left: 20px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .topology-title {
            color: #fff;
            font-size: 18px;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .topology-controls {
            position: absolute;
            top: 15px;
            right: 20px;
            z-index: 10;
            display: flex;
            gap: 8px;
        }

        .topo-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .topo-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
        }

        .topo-btn.active {
            background: #3498db;
            border-color: #3498db;
        }

        .topology-legend {
            position: absolute;
            bottom: 15px;
            left: 20px;
            z-index: 10;
            background: rgba(0,0,0,0.6);
            padding: 12px 16px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .legend-title {
            color: #fff;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            color: rgba(255,255,255,0.8);
            font-size: 11px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .legend-line {
            width: 24px;
            height: 3px;
            border-radius: 2px;
        }

        .topology-stats {
            position: absolute;
            bottom: 15px;
            right: 20px;
            z-index: 10;
            display: flex;
            gap: 20px;
        }

        .topo-stat {
            text-align: center;
            color: #fff;
        }

        .topo-stat-value {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .topo-stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
        }

        #topology-svg {
            width: 100%;
            height: 500px;
        }

        /* Node styles */
        .node-host {
            cursor: pointer;
            transition: transform 0.2s;
        }

        .node-host:hover {
            filter: brightness(1.2);
        }

        .node-switch {
            cursor: pointer;
        }

        .node-switch:hover {
            filter: brightness(1.3);
        }

        .node-label {
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 11px;
            fill: #fff;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }

        .node-sublabel {
            font-size: 9px;
            fill: rgba(255,255,255,0.6);
        }

        /* Tunnel link styles */
        .tunnel-link {
            fill: none;
            stroke-linecap: round;
            opacity: 0.8;
            transition: opacity 0.2s, stroke-width 0.2s;
        }

        .tunnel-link:hover {
            opacity: 1;
            stroke-width: 4px !important;
        }

        .tunnel-link-bg {
            fill: none;
            stroke: rgba(255,255,255,0.1);
            stroke-width: 8px;
            stroke-linecap: round;
        }

        /* Tooltip */
        .topo-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            max-width: 280px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .topo-tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: 600;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
        }

        .tooltip-label {
            color: rgba(255,255,255,0.6);
        }

        .tooltip-value {
            color: #fff;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        /* Animated gradient for tunnels */
        @keyframes flowAnimation {
            0% { stroke-dashoffset: 20; }
            100% { stroke-dashoffset: 0; }
        }

        .tunnel-animated {
            stroke-dasharray: 10 5;
            animation: flowAnimation 1s linear infinite;
        }

        /* Pulse animation for active nodes */
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        .node-active {
            animation: pulse 2s ease-in-out infinite;
        }

        /* Glow effect */
        .glow {
            filter: drop-shadow(0 0 8px currentColor);
        }
    </style>

    <script src="dojo/dojo.js" data-dojo-config="async: true"></script>
    <!-- D3.js for topology visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body class="claro">
    <div id="loading">
        <div style="font-size: 48px; margin-bottom: 20px;">üöÄ</div>
        <div>Loading Recira...</div>
        <div style="font-size: 14px; margin-top: 10px; color: #7f8c8d;">v0.7.2 - Visual Topology</div>
    </div>

    <div id="app-container">
        <div class="header">
            <h1>üåê Recira - Virtual Network Platform</h1>
            <div class="subtitle">Open Source SDN Platform for VXLAN Overlay Networks ‚Ä¢ v0.7.2</div>
        </div>

        <div class="content">
            <!-- Status Cards -->
            <div class="dashboard-grid">
                <div class="card">
                    <h2>üìä Controller Status</h2>
                    <div id="controller-status">
                        <div class="label">Status</div>
                        <div class="stat success">‚úì Running</div>
                        <div class="label">Uptime: <span id="uptime">Calculating...</span></div>
                    </div>
                </div>

                <div class="card">
                    <h2>üîå Connected Switches</h2>
                    <div id="switch-count">
                        <div class="stat info" id="switch-stat">...</div>
                        <div class="label">OpenFlow Switches</div>
                    </div>
                </div>

                <div class="card">
                    <h2>üîó Active Tunnels</h2>
                    <div id="tunnel-count">
                        <div class="stat warning" id="tunnel-stat">...</div>
                        <div class="label">VXLAN Tunnels</div>
                    </div>
                </div>

                <div class="card">
                    <h2>üñ•Ô∏è Managed Hosts</h2>
                    <div id="host-count">
                        <div class="stat" id="host-stat">...</div>
                        <div class="label">Linux Hosts</div>
                    </div>
                </div>

                <div class="card">
                    <h2>üåê Virtual Networks</h2>
                    <div id="network-count">
                        <div class="stat success" id="network-stat">...</div>
                        <div class="label">Configured Networks</div>
                    </div>
                </div>
            </div>

            <!-- Actions -->
            <div class="card" style="margin-bottom: 20px;">
                <h2>‚ö° Quick Actions</h2>
                <button class="btn" onclick="showAddHostModal()">‚ûï Add Host</button>
                <button class="btn" onclick="showProvisionHostModal()">üöÄ Provision Host</button>
                <button class="btn" onclick="showCreateNetworkModal()">üåê Create Network</button>
                <button class="btn" onclick="showCreateTunnelModal()">üîó Create Tunnel</button>
                <button class="btn" onclick="refreshData()">üîÑ Refresh Data</button>
                <button class="btn" onclick="window.location.href='/api/status'">üì° View API</button>
            </div>

            <!-- Network Topology Visualization -->
            <div class="card" style="margin-bottom: 20px; padding: 0; overflow: hidden;">
                <div class="topology-container" id="topology-container">
                    <div class="topology-header">
                        <span class="topology-title">üó∫Ô∏è VXLAN Overlay Topology</span>
                        <span style="color: rgba(255,255,255,0.5); font-size: 11px;">Real-time Network View</span>
                    </div>

                    <div class="topology-controls">
                        <button class="topo-btn active" onclick="setTopologyView('all')" id="view-all">All VNIs</button>
                        <button class="topo-btn" onclick="toggleAnimation()" id="btn-animate">‚è∏Ô∏è Pause</button>
                        <button class="topo-btn" onclick="resetTopology()">üîÑ Reset</button>
                        <button class="topo-btn" onclick="toggleFullscreen()">‚õ∂ Expand</button>
                    </div>

                    <svg id="topology-svg"></svg>

                    <div class="topology-legend" id="topology-legend">
                        <div class="legend-title">Legend</div>
                        <div class="legend-items">
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #667eea, #764ba2);"></div>
                                <span>Host Server</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #3498db; border-radius: 50%;"></div>
                                <span>OVS Bridge</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-line tunnel-animated" style="background: linear-gradient(90deg, #00d2ff, #3a7bd5);"></div>
                                <span>VXLAN Tunnel</span>
                            </div>
                        </div>
                    </div>

                    <div class="topology-stats">
                        <div class="topo-stat">
                            <div class="topo-stat-value" id="topo-hosts">0</div>
                            <div class="topo-stat-label">Hosts</div>
                        </div>
                        <div class="topo-stat">
                            <div class="topo-stat-value" id="topo-switches">0</div>
                            <div class="topo-stat-label">Switches</div>
                        </div>
                        <div class="topo-stat">
                            <div class="topo-stat-value" id="topo-tunnels">0</div>
                            <div class="topo-stat-label">Tunnels</div>
                        </div>
                        <div class="topo-stat">
                            <div class="topo-stat-value" id="topo-vnis">0</div>
                            <div class="topo-stat-label">VNIs</div>
                        </div>
                    </div>

                    <div class="topo-tooltip" id="topo-tooltip"></div>
                </div>
            </div>

            <!-- Switches Table -->
            <div class="card">
                <h2>üîå OpenFlow Switches</h2>
                <table id="switches-table">
                    <thead>
                        <tr>
                            <th>DPID</th>
                            <th>Name</th>
                            <th>Host</th>
                            <th>Status</th>
                            <th>Ports</th>
                            <th>Flows</th>
                        </tr>
                    </thead>
                    <tbody id="switches-body">
                        <tr><td colspan="6" style="text-align: center;">Loading...</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Managed Hosts Table -->
            <div class="card" style="margin-top: 20px;">
                <h2>üñ•Ô∏è Managed Hosts</h2>
                <table id="hosts-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Hostname</th>
                            <th>Management IP</th>
                            <th>VXLAN IP</th>
                            <th>Type</th>
                            <th>OVS Version</th>
                            <th>Bridges</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="hosts-body">
                        <tr><td colspan="8" style="text-align: center;">Loading...</td></tr>
                    </tbody>
                </table>
                <!-- Detached Hosts Section -->
                <div id="detached-hosts-section" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #3c3c3c;">
                    <h3 style="color: #f39c12; font-size: 14px; margin-bottom: 10px;">üì¶ Detached Hosts (can re-attach)</h3>
                    <table id="detached-hosts-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Hostname</th>
                                <th>IP</th>
                                <th>Last Bridges</th>
                                <th>Detached At</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="detached-hosts-body">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Virtual Networks Table -->
            <div class="card" style="margin-top: 20px;">
                <h2>üåê Virtual Networks</h2>
                <table id="networks-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>VNI</th>
                            <th>Subnet</th>
                            <th>Gateway</th>
                            <th>DHCP</th>
                            <th>Switches</th>
                            <th>Tunnels</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="networks-body">
                        <tr><td colspan="9" style="text-align: center;">Loading...</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Tunnels Table -->
            <div class="card" style="margin-top: 20px;">
                <h2>üîó VXLAN Tunnels</h2>
                <table id="tunnels-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Source</th>
                            <th>Destination</th>
                            <th>VNI</th>
                            <th>Underlay IPs</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="tunnels-body">
                        <tr><td colspan="7" style="text-align: center;">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Create Tunnel Modal -->
    <div id="createTunnelModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üîó Create VXLAN Tunnel</div>
            <form id="tunnelForm">
                <div class="form-group">
                    <label>Source Switch</label>
                    <select id="srcSwitch" required>
                        <option value="">Select source switch...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Destination Switch</label>
                    <select id="dstSwitch" required>
                        <option value="">Select destination switch...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>VNI (VXLAN Network Identifier)</label>
                    <input type="number" id="vni" placeholder="Auto-assign if left empty" min="1" max="16777215">
                </div>
                <div>
                    <button type="submit" class="btn-primary">Create Tunnel</button>
                    <button type="button" class="btn-secondary" onclick="closeCreateTunnelModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Add Host Modal -->
    <div id="addHostModal" class="modal">
        <div class="modal-content" style="width: 700px;">
            <div class="modal-header">‚ûï Add Remote Host</div>

            <!-- Step 1: Credentials -->
            <div id="addHostStep1">
                <div class="form-group">
                    <label>Host IP Address (Management Network)</label>
                    <input type="text" id="addHostIP" placeholder="192.168.88.100" required>
                </div>
                <div class="form-group">
                    <label>SSH Username</label>
                    <input type="text" id="addHostUsername" value="root" required>
                </div>
                <div class="form-group">
                    <label>SSH Password</label>
                    <input type="password" id="addHostPassword" required>
                </div>
                <div style="margin-bottom: 15px; padding: 10px; background: #e8f4f8; border-radius: 4px; font-size: 13px;">
                    <strong>Next step:</strong> We'll scan the host's network interfaces so you can select which one to use for VXLAN tunnels.
                </div>
                <div>
                    <button type="button" class="btn-primary" onclick="scanAddHostInterfaces()">Scan Interfaces</button>
                    <button type="button" class="btn-secondary" onclick="closeAddHostModal()">Cancel</button>
                </div>
            </div>

            <!-- Step 2: Interface Selection -->
            <div id="addHostStep2" style="display: none;">
                <div style="margin-bottom: 15px; padding: 10px; background: #e8f4f8; border-radius: 4px; font-size: 13px;">
                    Select which interface to use for VXLAN overlay network (typically the one with larger MTU or 10.x network):
                </div>
                <div id="addHostInterfacesContainer" style="margin-bottom: 20px;">
                    <table style="width: 100%; font-size: 13px;">
                        <thead>
                            <tr>
                                <th style="width: 60px;">VXLAN</th>
                                <th>Interface</th>
                                <th>IP Address</th>
                                <th>MTU</th>
                                <th>State</th>
                            </tr>
                        </thead>
                        <tbody id="addHostInterfacesList">
                        </tbody>
                    </table>
                </div>
                <div>
                    <button type="button" class="btn-primary" onclick="submitAddHost()">Add Host</button>
                    <button type="button" class="btn-secondary" onclick="backToAddHostStep1()">Back</button>
                    <button type="button" class="btn-secondary" onclick="closeAddHostModal()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Provision Host Modal -->
    <div id="provisionHostModal" class="modal">
        <div class="modal-content" style="width: 700px;">
            <div class="modal-header">üöÄ Provision New Host</div>

            <!-- Step 1: Credentials -->
            <div id="provisionStep1">
                <div class="form-group">
                    <label>Host IP Address (Management Network)</label>
                    <input type="text" id="provisionHostIP" placeholder="192.168.88.100" required>
                </div>
                <div class="form-group">
                    <label>SSH Username</label>
                    <input type="text" id="provisionHostUsername" value="root" required>
                </div>
                <div class="form-group">
                    <label>SSH Password</label>
                    <input type="password" id="provisionHostPassword" required>
                </div>
                <div style="margin-bottom: 15px; padding: 10px; background: #e8f4f8; border-radius: 4px; font-size: 13px;">
                    <strong>Next step:</strong> We'll scan the host's network interfaces so you can select which one to use for VXLAN tunnels.
                </div>
                <div>
                    <button type="button" class="btn-primary" onclick="scanProvisionInterfaces()">Scan Interfaces</button>
                    <button type="button" class="btn-secondary" onclick="closeProvisionHostModal()">Cancel</button>
                </div>
            </div>

            <!-- Step 2: Interface Selection -->
            <div id="provisionStep2" style="display: none;">
                <div style="margin-bottom: 15px; padding: 10px; background: #e8f4f8; border-radius: 4px; font-size: 13px;">
                    Select which interface to use for VXLAN overlay network (typically the one with larger MTU or 10.x network):
                </div>
                <div id="provisionInterfacesContainer" style="margin-bottom: 20px;">
                    <table style="width: 100%; font-size: 13px;">
                        <thead>
                            <tr>
                                <th style="width: 60px;">VXLAN</th>
                                <th>Interface</th>
                                <th>IP Address</th>
                                <th>MTU</th>
                                <th>State</th>
                            </tr>
                        </thead>
                        <tbody id="provisionInterfacesList">
                        </tbody>
                    </table>
                </div>
                <div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-radius: 4px; font-size: 13px;">
                    <strong>‚ö†Ô∏è Provisioning will:</strong><br>
                    ‚Ä¢ Detect OS type (Ubuntu/Debian/CentOS)<br>
                    ‚Ä¢ Install Open vSwitch automatically<br>
                    ‚Ä¢ Configure MTU to 9000 on VXLAN interface<br>
                    ‚Ä¢ Apply performance optimizations<br>
                    <br>
                    <strong>‚è±Ô∏è This may take 5-10 minutes!</strong>
                </div>
                <div>
                    <button type="button" class="btn-primary" onclick="submitProvisionHost()">Start Provisioning</button>
                    <button type="button" class="btn-secondary" onclick="backToProvisionStep1()">Back</button>
                    <button type="button" class="btn-secondary" onclick="closeProvisionHostModal()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Network Modal -->
    <div id="createNetworkModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üåê Create Virtual Network</div>
            <form id="networkForm">
                <div class="form-group">
                    <label>Network Name</label>
                    <input type="text" id="networkName" placeholder="Production" required>
                </div>
                <div class="form-group">
                    <label>Switches (Select multiple)</label>
                    <select id="networkSwitches" multiple size="4" required style="height: 120px;">
                        <option value="">Loading switches...</option>
                    </select>
                    <div style="font-size: 12px; color: #7f8c8d; margin-top: 5px;">
                        Hold Ctrl (Cmd on Mac) to select multiple switches
                    </div>
                </div>
                <div class="form-group">
                    <label>VNI (Optional - auto-assigned if empty)</label>
                    <input type="number" id="networkVNI" placeholder="Auto-assign" min="1" max="16777215">
                </div>
                <div class="form-group">
                    <label>Subnet (Optional)</label>
                    <input type="text" id="networkSubnet" placeholder="10.0.1.0/24">
                </div>
                <div class="form-group">
                    <label>Gateway (Optional)</label>
                    <input type="text" id="networkGateway" placeholder="10.0.1.1">
                </div>
                <div style="margin-bottom: 15px; padding: 10px; background: #e8f4f8; border-radius: 4px; font-size: 13px;">
                    <strong>Note:</strong> This will automatically create full-mesh VXLAN tunnels between all selected switches.
                </div>
                <div>
                    <button type="submit" class="btn-primary">Create Network</button>
                    <button type="button" class="btn-secondary" onclick="closeCreateNetworkModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Enable DHCP Modal -->
    <div id="enableDHCPModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üñß Enable DHCP for Network</div>
            <form id="dhcpForm">
                <input type="hidden" id="dhcpNetworkId">
                <div class="form-group">
                    <label>Network</label>
                    <input type="text" id="dhcpNetworkName" readonly style="background: #f0f0f0;">
                </div>
                <div class="form-group">
                    <label>DHCP Server Host (select which host runs dnsmasq)</label>
                    <select id="dhcpHostSelect" required>
                        <option value="">Select host...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>DHCP Range Start</label>
                    <input type="text" id="dhcpStart" placeholder="10.0.1.10" required>
                </div>
                <div class="form-group">
                    <label>DHCP Range End</label>
                    <input type="text" id="dhcpEnd" placeholder="10.0.1.250" required>
                </div>
                <div class="form-group">
                    <label>DNS Servers (comma-separated)</label>
                    <input type="text" id="dhcpDNS" value="8.8.8.8, 8.8.4.4">
                </div>
                <div class="form-group">
                    <label>Lease Time</label>
                    <select id="dhcpLeaseTime">
                        <option value="1h">1 hour</option>
                        <option value="6h">6 hours</option>
                        <option value="12h">12 hours</option>
                        <option value="24h" selected>24 hours</option>
                        <option value="48h">48 hours</option>
                        <option value="168h">1 week</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>SSH Password (for DHCP host)</label>
                    <input type="password" id="dhcpPassword" placeholder="SSH password for selected host" required>
                </div>
                <div style="margin-bottom: 15px; padding: 10px; background: #fef9e7; border-radius: 4px; font-size: 13px;">
                    <strong>Note:</strong> This will install dnsmasq (if needed), create a gateway port on OVS, and start DHCP service on the selected host.
                </div>
                <div>
                    <button type="submit" class="btn-primary">Enable DHCP</button>
                    <button type="button" class="btn-secondary" onclick="closeEnableDHCPModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- DHCP Leases Modal -->
    <div id="dhcpLeasesModal" class="modal">
        <div class="modal-content" style="width: 600px;">
            <div class="modal-header">üìã DHCP Leases</div>
            <div id="dhcpLeasesContent">
                <p style="text-align: center; color: #7f8c8d;">Loading leases...</p>
            </div>
            <div style="margin-top: 20px;">
                <button type="button" class="btn" onclick="refreshDHCPLeases()">üîÑ Refresh</button>
                <button type="button" class="btn-secondary" onclick="closeDHCPLeasesModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Global switches array
        let allSwitches = [];
        let currentDHCPNetworkId = null;

        // Hide loading, show app
        setTimeout(function() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('app-container').style.display = 'block';
            loadData();
        }, 1000);

        // Modal functions
        function showCreateTunnelModal() {
            populateSwitchDropdowns();
            document.getElementById('createTunnelModal').style.display = 'block';
        }

        function closeCreateTunnelModal() {
            document.getElementById('createTunnelModal').style.display = 'none';
            document.getElementById('tunnelForm').reset();
        }

        function populateSwitchDropdowns() {
            const srcSelect = document.getElementById('srcSwitch');
            const dstSelect = document.getElementById('dstSwitch');

            // Clear existing options
            srcSelect.innerHTML = '<option value="">Select source switch...</option>';
            dstSelect.innerHTML = '<option value="">Select destination switch...</option>';

            // Add switches
            allSwitches.forEach(sw => {
                const optionText = `${sw.name}@${sw.hostname} (DPID: ${sw.dpid})`;
                srcSelect.add(new Option(optionText, sw.id));
                dstSelect.add(new Option(optionText, sw.id));
            });
        }

        // Handle form submissions
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('tunnelForm').addEventListener('submit', function(e) {
                e.preventDefault();
                createTunnel();
            });

            document.getElementById('addHostForm').addEventListener('submit', function(e) {
                e.preventDefault();
                addHost();
            });

            // Provision host now uses button click handlers instead of form submit
            // Network form event listener is attached in showCreateNetworkModal() to ensure form exists
        });

        function createTunnel() {
            const srcId = document.getElementById('srcSwitch').value;
            const dstId = document.getElementById('dstSwitch').value;
            const vni = document.getElementById('vni').value;

            if (!srcId || !dstId) {
                alert('Please select both source and destination switches');
                return;
            }

            if (srcId === dstId) {
                alert('Source and destination must be different switches');
                return;
            }

            const data = {
                src_switch_id: parseInt(srcId),
                dst_switch_id: parseInt(dstId)
            };

            if (vni) {
                data.vni = parseInt(vni);
            }

            fetch('/api/tunnels/create', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(data)
            })
            .then(r => r.json())
            .then(response => {
                if (response.success) {
                    alert('Tunnel created successfully!');
                    closeCreateTunnelModal();
                    loadData();
                } else {
                    alert('Error creating tunnel: ' + (response.error || 'Unknown error'));
                }
            })
            .catch(e => {
                alert('Failed to create tunnel: ' + e);
            });
        }

        function deleteTunnel(tunnelId) {
            if (!confirm('Are you sure you want to delete this tunnel?')) {
                return;
            }

            fetch('/api/tunnels/delete', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({tunnel_id: tunnelId})
            })
            .then(r => r.json())
            .then(response => {
                if (response.success) {
                    alert('Tunnel deleted successfully!');
                    loadData();
                } else {
                    alert('Error deleting tunnel: ' + (response.error || 'Unknown error'));
                }
            })
            .catch(e => {
                alert('Failed to delete tunnel: ' + e);
            });
        }

        // Add Host modal functions
        function showAddHostModal() {
            document.getElementById('addHostModal').style.display = 'block';
        }

        function closeAddHostModal() {
            document.getElementById('addHostModal').style.display = 'none';
            // Reset both steps
            document.getElementById('addHostStep1').style.display = 'block';
            document.getElementById('addHostStep2').style.display = 'none';
            // Reset form fields
            document.getElementById('addHostIP').value = '';
            document.getElementById('addHostUsername').value = 'root';
            document.getElementById('addHostPassword').value = '';
            addHostScannedInterfaces = [];
        }

        // Global state for Add Host scanned interfaces
        let addHostScannedInterfaces = [];

        function scanAddHostInterfaces() {
            const ip = document.getElementById('addHostIP').value;
            const username = document.getElementById('addHostUsername').value;
            const password = document.getElementById('addHostPassword').value;

            if (!ip || !password) {
                alert('Please fill in all required fields');
                return;
            }

            // Show loading state
            const scanBtn = event.target;
            const originalText = scanBtn.textContent;
            scanBtn.disabled = true;
            scanBtn.textContent = 'Scanning...';

            fetch(`/api/hosts/scan-interfaces?ip=${encodeURIComponent(ip)}&username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`)
                .then(r => r.json())
                .then(response => {
                    scanBtn.disabled = false;
                    scanBtn.textContent = originalText;

                    if (response.success && response.interfaces) {
                        addHostScannedInterfaces = response.interfaces;
                        displayAddHostInterfaces(response.interfaces);
                        document.getElementById('addHostStep1').style.display = 'none';
                        document.getElementById('addHostStep2').style.display = 'block';
                    } else {
                        alert('Failed to scan interfaces: ' + (response.error || 'Unknown error'));
                    }
                })
                .catch(e => {
                    scanBtn.disabled = false;
                    scanBtn.textContent = originalText;
                    alert('Failed to scan interfaces: ' + e);
                });
        }

        function displayAddHostInterfaces(interfaces) {
            const tbody = document.getElementById('addHostInterfacesList');
            tbody.innerHTML = '';

            interfaces.forEach((iface, index) => {
                const row = document.createElement('tr');
                // Auto-suggest VXLAN interface (10.172.x or MTU 9000)
                const isVxlanSuggested = iface.ip.startsWith('10.172.') || iface.mtu == '9000';

                row.innerHTML = `
                    <td><input type="radio" name="addHostVxlanInterface" value="${index}" ${isVxlanSuggested ? 'checked' : ''}></td>
                    <td><strong>${iface.name}</strong></td>
                    <td>${iface.cidr}</td>
                    <td>${iface.mtu}</td>
                    <td><span style="color: ${iface.state === 'up' ? 'green' : 'red'}">${iface.state}</span></td>
                `;
                tbody.appendChild(row);
            });
        }

        function backToAddHostStep1() {
            document.getElementById('addHostStep1').style.display = 'block';
            document.getElementById('addHostStep2').style.display = 'none';
        }

        function submitAddHost() {
            const selectedRadio = document.querySelector('input[name="addHostVxlanInterface"]:checked');
            if (!selectedRadio) {
                alert('Please select which interface to use for VXLAN overlay');
                return;
            }

            const vxlanInterfaceIndex = parseInt(selectedRadio.value);
            const vxlanInterface = addHostScannedInterfaces[vxlanInterfaceIndex];
            const managementIP = document.getElementById('addHostIP').value;
            const username = document.getElementById('addHostUsername').value;
            const password = document.getElementById('addHostPassword').value;

            // Disable button to prevent double-submission
            const submitBtn = event.target;
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Adding Host...';

            fetch('/api/hosts/add', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    ip: managementIP,
                    username: username,
                    password: password,
                    vxlan_ip: vxlanInterface.ip
                })
            })
            .then(r => r.json())
            .then(response => {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;

                if (response.success) {
                    alert(`Host added successfully!\n\nHostname: ${response.host.hostname}\nManagement IP: ${managementIP}\nVXLAN IP: ${vxlanInterface.ip}\nOVS Version: ${response.host.ovs_version}\nBridges: ${response.host.bridges.length}`);
                    closeAddHostModal();
                    loadData();
                } else {
                    alert('Error adding host: ' + (response.error || 'Unknown error'));
                }
            })
            .catch(e => {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
                alert('Failed to add host: ' + e);
            });
        }

        // Host Management Functions (Detach, Forget, Re-attach)
        function detachHost(hostId, hostname) {
            if (!confirm(`Detach host "${hostname}"?\n\nThe host will be removed from active management but its data will be preserved. You can re-attach it later.`)) {
                return;
            }

            fetch('/api/hosts/remove', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    host_id: hostId,
                    keep_data: true  // Detach = keep data
                })
            })
            .then(r => r.json())
            .then(response => {
                if (response.success) {
                    alert(`Host "${hostname}" detached successfully.\n\nYou can re-attach it later from the "Detached Hosts" section.`);
                    loadData();
                } else {
                    alert('Error detaching host: ' + (response.message || 'Unknown error'));
                }
            })
            .catch(e => {
                alert('Failed to detach host: ' + e);
            });
        }

        function forgetHost(hostId, hostname) {
            if (!confirm(`PERMANENTLY DELETE host "${hostname}"?\n\n‚ö†Ô∏è This action cannot be undone!\nAll host data will be permanently removed.`)) {
                return;
            }

            // Double confirmation for destructive action
            if (!confirm(`Are you SURE you want to permanently delete "${hostname}"?\n\nType OK to confirm.`)) {
                return;
            }

            fetch('/api/hosts/remove', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    host_id: hostId,
                    keep_data: false  // Forget = delete data
                })
            })
            .then(r => r.json())
            .then(response => {
                if (response.success) {
                    alert(`Host "${hostname}" permanently removed.`);
                    loadData();
                } else {
                    alert('Error removing host: ' + (response.message || 'Unknown error'));
                }
            })
            .catch(e => {
                alert('Failed to remove host: ' + e);
            });
        }

        function reattachHost(hostId, hostname) {
            if (!confirm(`Re-attach host "${hostname}"?\n\nThe system will try to reconnect to the host using saved credentials.`)) {
                return;
            }

            fetch('/api/hosts/reattach', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    host_id: hostId
                })
            })
            .then(r => r.json())
            .then(response => {
                if (response.success) {
                    alert(`Host "${hostname}" re-attached successfully!`);
                    loadData();
                } else {
                    alert('Error re-attaching host: ' + (response.message || 'Unknown error'));
                }
            })
            .catch(e => {
                alert('Failed to re-attach host: ' + e);
            });
        }

        // Provision Host modal functions (Two-step workflow with interface selection)
        let provisionScannedInterfaces = [];

        function showProvisionHostModal() {
            document.getElementById('provisionHostModal').style.display = 'block';
            document.getElementById('provisionStep1').style.display = 'block';
            document.getElementById('provisionStep2').style.display = 'none';
        }

        function closeProvisionHostModal() {
            document.getElementById('provisionHostModal').style.display = 'none';
            document.getElementById('provisionHostIP').value = '';
            document.getElementById('provisionHostUsername').value = 'root';
            document.getElementById('provisionHostPassword').value = '';
            document.getElementById('provisionStep1').style.display = 'block';
            document.getElementById('provisionStep2').style.display = 'none';
            provisionScannedInterfaces = [];
        }

        function backToProvisionStep1() {
            document.getElementById('provisionStep1').style.display = 'block';
            document.getElementById('provisionStep2').style.display = 'none';
        }

        function scanProvisionInterfaces() {
            const ip = document.getElementById('provisionHostIP').value;
            const username = document.getElementById('provisionHostUsername').value;
            const password = document.getElementById('provisionHostPassword').value;

            if (!ip || !password) {
                alert('Please fill in all required fields');
                return;
            }

            // Show loading state
            const scanBtn = event.target;
            const originalText = scanBtn.textContent;
            scanBtn.disabled = true;
            scanBtn.textContent = 'Scanning...';

            fetch(`/api/hosts/scan-interfaces?ip=${encodeURIComponent(ip)}&username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`)
                .then(r => r.json())
                .then(response => {
                    scanBtn.disabled = false;
                    scanBtn.textContent = originalText;

                    if (response.success && response.interfaces) {
                        provisionScannedInterfaces = response.interfaces;
                        displayProvisionInterfaces(response.interfaces);
                        document.getElementById('provisionStep1').style.display = 'none';
                        document.getElementById('provisionStep2').style.display = 'block';
                    } else {
                        alert('Failed to scan interfaces: ' + (response.error || 'Unknown error'));
                    }
                })
                .catch(e => {
                    scanBtn.disabled = false;
                    scanBtn.textContent = originalText;
                    alert('Failed to scan interfaces: ' + e);
                });
        }

        function displayProvisionInterfaces(interfaces) {
            const tbody = document.getElementById('provisionInterfacesList');
            tbody.innerHTML = '';

            interfaces.forEach((iface, index) => {
                const row = document.createElement('tr');
                const isVxlanSuggested = iface.ip.startsWith('10.172.') || iface.mtu == '9000';

                row.innerHTML = `
                    <td><input type="radio" name="vxlanInterface" value="${index}" ${isVxlanSuggested ? 'checked' : ''}></td>
                    <td><strong>${iface.name}</strong></td>
                    <td>${iface.cidr}</td>
                    <td>${iface.mtu}</td>
                    <td><span style="color: ${iface.state === 'up' ? 'green' : 'red'}">${iface.state}</span></td>
                `;
                tbody.appendChild(row);
            });
        }

        function submitProvisionHost() {
            const selectedRadio = document.querySelector('input[name="vxlanInterface"]:checked');
            if (!selectedRadio) {
                alert('Please select which interface to use for VXLAN overlay');
                return;
            }

            const vxlanInterfaceIndex = parseInt(selectedRadio.value);
            const vxlanInterface = provisionScannedInterfaces[vxlanInterfaceIndex];
            const managementIP = document.getElementById('provisionHostIP').value;
            const username = document.getElementById('provisionHostUsername').value;
            const password = document.getElementById('provisionHostPassword').value;

            if (!confirm(`Provision host with VXLAN on ${vxlanInterface.name} (${vxlanInterface.ip})?\n\nThis may take 5-10 minutes.`)) {
                return;
            }

            // Show progress
            const submitBtn = event.target;
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Provisioning... (this may take several minutes)';

            fetch('/api/hosts/provision', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    ip: managementIP,
                    username: username,
                    password: password,
                    vxlan_interface: vxlanInterface.name,
                    vxlan_ip: vxlanInterface.ip,
                    configure_mtu: true,
                    optimize: true
                })
            })
            .then(r => r.json())
            .then(response => {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;

                if (response.success) {
                    const details = response.provision_details;
                    alert(`Host provisioned successfully!\n\n` +
                          `OS: ${details.os_type} ${details.os_version}\n` +
                          `OVS Version: ${details.ovs_version}\n` +
                          `Management IP: ${managementIP}\n` +
                          `VXLAN IP: ${vxlanInterface.ip}\n` +
                          `MTU Configured: ${details.mtu_configured ? 'Yes' : 'No'}\n` +
                          `Optimizations: ${details.optimizations_applied ? 'Applied' : 'Not applied'}`);
                    closeProvisionHostModal();
                    loadData();
                } else {
                    alert('Error provisioning host: ' + (response.error || 'Unknown error'));
                }
            })
            .catch(e => {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
                alert('Failed to provision host: ' + e);
            });
        }

        // Create Network modal functions
        let networkFormListenerAttached = false;  // Flag to ensure listener is only attached once

        function showCreateNetworkModal() {
            populateNetworkSwitches();
            document.getElementById('createNetworkModal').style.display = 'block';

            // Attach event listener to form when modal is shown (ensures form exists in DOM)
            if (!networkFormListenerAttached) {
                const networkForm = document.getElementById('networkForm');
                if (networkForm) {
                    console.log('‚úÖ Network form found in modal, attaching event listener');
                    networkForm.addEventListener('submit', function(e) {
                        console.log('üî• Form submit event fired!');
                        e.preventDefault();
                        createNetwork();
                    });
                    networkFormListenerAttached = true;
                } else {
                    console.error('‚ùå ERROR: networkForm still not found in modal!');
                }
            }
        }

        function closeCreateNetworkModal() {
            document.getElementById('createNetworkModal').style.display = 'none';
            document.getElementById('networkForm').reset();
        }

        function populateNetworkSwitches() {
            const select = document.getElementById('networkSwitches');
            select.innerHTML = '';

            allSwitches.forEach(sw => {
                const optionText = `${sw.name}@${sw.hostname} (DPID: ${sw.dpid})`;
                const option = new Option(optionText, sw.id);
                select.add(option);
            });
        }

        function createNetwork() {
            console.log('üöÄ createNetwork() called!');
            alert('[DEBUG] createNetwork() function called! Check console for details.');

            const name = document.getElementById('networkName').value;
            const switchSelect = document.getElementById('networkSwitches');
            const selectedSwitches = Array.from(switchSelect.selectedOptions).map(opt => parseInt(opt.value));
            const vni = document.getElementById('networkVNI').value;
            const subnet = document.getElementById('networkSubnet').value;
            const gateway = document.getElementById('networkGateway').value;

            console.log('Selected switches:', selectedSwitches);

            if (!name) {
                alert('Please enter a network name');
                return;
            }

            if (selectedSwitches.length < 2) {
                alert('Please select at least 2 switches for the network');
                return;
            }

            const data = {
                name: name,
                switches: selectedSwitches,
                subnet: subnet,
                gateway: gateway
            };

            if (vni) {
                data.vni = parseInt(vni);
            }

            console.log('Sending network create request:', data);

            // Disable button (with null check)
            const submitBtn = document.querySelector('#networkForm button[type="submit"]');
            if (!submitBtn) {
                console.error('Submit button not found!');
                alert('UI Error: Submit button not found. Please refresh the page.');
                return;
            }

            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Creating Network...';

            fetch('/api/networks/create', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(data)
            })
            .then(r => r.json())
            .then(response => {
                console.log('Network create response:', response);
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;

                if (response.success) {
                    const network = response.network;
                    alert('Network created successfully!\\n\\n' +
                          'Name: ' + network.name + '\\n' +
                          'VNI: ' + network.vni + '\\n' +
                          'Switches: ' + network.switches.length + '\\n' +
                          'Tunnels Created: ' + network.tunnels.length);
                    closeCreateNetworkModal();
                    loadData();
                } else {
                    alert('Error creating network: ' + (response.error || 'Unknown error'));
                }
            })
            .catch(e => {
                console.error('Network create error:', e);
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
                alert('Failed to create network: ' + e);
            });
        }

        function deleteNetwork(networkId) {
            if (!confirm('Are you sure you want to delete this network? This will also delete all associated tunnels.')) {
                return;
            }

            fetch('/api/networks/delete', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({network_id: networkId})
            })
            .then(r => r.json())
            .then(response => {
                if (response.success) {
                    alert('Network deleted successfully!');
                    loadData();
                } else {
                    alert('Error deleting network: ' + (response.error || 'Unknown error'));
                }
            })
            .catch(e => {
                alert('Failed to delete network: ' + e);
            });
        }

        // ============ DHCP Functions (v0.7) ============

        function showEnableDHCPModal(networkId, networkName, subnet, gateway) {
            currentDHCPNetworkId = networkId;
            document.getElementById('dhcpNetworkId').value = networkId;
            document.getElementById('dhcpNetworkName').value = networkName + ' (VNI ' + networkId + ')';

            // Parse subnet to suggest DHCP range
            if (subnet && gateway) {
                const parts = gateway.split('.');
                if (parts.length === 4) {
                    const base = parts.slice(0, 3).join('.');
                    document.getElementById('dhcpStart').value = base + '.10';
                    document.getElementById('dhcpEnd').value = base + '.250';
                }
            }

            // Populate host dropdown
            fetch('/api/hosts')
                .then(r => r.json())
                .then(data => {
                    const select = document.getElementById('dhcpHostSelect');
                    select.innerHTML = '<option value="">Select host...</option>';
                    data.hosts.forEach(host => {
                        const option = document.createElement('option');
                        option.value = host.ip;
                        option.textContent = `${host.hostname} (${host.ip})`;
                        select.appendChild(option);
                    });
                });

            document.getElementById('enableDHCPModal').style.display = 'block';
        }

        function closeEnableDHCPModal() {
            document.getElementById('enableDHCPModal').style.display = 'none';
            document.getElementById('dhcpForm').reset();
        }

        // Handle DHCP form submission
        document.addEventListener('DOMContentLoaded', function() {
            const dhcpForm = document.getElementById('dhcpForm');
            if (dhcpForm) {
                dhcpForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    enableDHCP();
                });
            }
        });

        function enableDHCP() {
            const networkId = document.getElementById('dhcpNetworkId').value;
            const hostIp = document.getElementById('dhcpHostSelect').value;
            const dhcpStart = document.getElementById('dhcpStart').value;
            const dhcpEnd = document.getElementById('dhcpEnd').value;
            const dnsServers = document.getElementById('dhcpDNS').value.split(',').map(s => s.trim());
            const leaseTime = document.getElementById('dhcpLeaseTime').value;
            const password = document.getElementById('dhcpPassword').value;

            if (!hostIp || !dhcpStart || !dhcpEnd || !password) {
                alert('Please fill in all required fields');
                return;
            }

            const submitBtn = document.querySelector('#dhcpForm button[type="submit"]');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Enabling DHCP...';

            fetch('/api/dhcp/enable', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    network_id: networkId,
                    host_ip: hostIp,
                    dhcp_start: dhcpStart,
                    dhcp_end: dhcpEnd,
                    dns_servers: dnsServers,
                    lease_time: leaseTime,
                    password: password
                })
            })
            .then(r => r.json())
            .then(response => {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;

                if (response.success) {
                    alert('DHCP enabled successfully!\n\nDHCP Range: ' + dhcpStart + ' - ' + dhcpEnd);
                    closeEnableDHCPModal();
                    loadData();
                } else {
                    alert('Error enabling DHCP: ' + (response.message || response.error || 'Unknown error'));
                }
            })
            .catch(e => {
                console.error('DHCP enable error:', e);
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
                alert('Failed to enable DHCP: ' + e);
            });
        }

        function disableDHCP(networkId) {
            if (!confirm('Are you sure you want to disable DHCP for this network?')) {
                return;
            }

            const password = prompt('Enter SSH password for DHCP host:');
            if (!password) return;

            fetch('/api/dhcp/disable', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    network_id: networkId,
                    password: password
                })
            })
            .then(r => r.json())
            .then(response => {
                if (response.success) {
                    alert('DHCP disabled successfully!');
                    loadData();
                } else {
                    alert('Error disabling DHCP: ' + (response.message || response.error || 'Unknown error'));
                }
            })
            .catch(e => {
                alert('Failed to disable DHCP: ' + e);
            });
        }

        function showDHCPLeases(networkId) {
            currentDHCPNetworkId = networkId;
            document.getElementById('dhcpLeasesModal').style.display = 'block';
            refreshDHCPLeases();
        }

        function closeDHCPLeasesModal() {
            document.getElementById('dhcpLeasesModal').style.display = 'none';
            currentDHCPNetworkId = null;
        }

        function refreshDHCPLeases() {
            if (!currentDHCPNetworkId) return;

            document.getElementById('dhcpLeasesContent').innerHTML =
                '<p style="text-align: center; color: #7f8c8d;">Loading leases...</p>';

            fetch('/api/dhcp/leases?network_id=' + currentDHCPNetworkId)
                .then(r => r.json())
                .then(response => {
                    if (response.success) {
                        if (response.leases.length === 0) {
                            document.getElementById('dhcpLeasesContent').innerHTML =
                                '<p style="text-align: center; color: #7f8c8d;">No active leases</p>';
                        } else {
                            let html = '<table style="width: 100%; font-size: 13px;">';
                            html += '<thead><tr><th>IP Address</th><th>MAC Address</th><th>Hostname</th><th>Expires</th></tr></thead>';
                            html += '<tbody>';
                            response.leases.forEach(lease => {
                                html += `<tr>
                                    <td>${lease.ip}</td>
                                    <td><code style="font-size: 11px;">${lease.mac}</code></td>
                                    <td>${lease.hostname || '-'}</td>
                                    <td>${lease.expires_at || '-'}</td>
                                </tr>`;
                            });
                            html += '</tbody></table>';
                            document.getElementById('dhcpLeasesContent').innerHTML = html;
                        }
                    } else {
                        document.getElementById('dhcpLeasesContent').innerHTML =
                            '<p style="color: red;">Error: ' + (response.message || response.error) + '</p>';
                    }
                })
                .catch(e => {
                    document.getElementById('dhcpLeasesContent').innerHTML =
                        '<p style="color: red;">Failed to load leases: ' + e + '</p>';
                });
        }

        // ============ End DHCP Functions ============

        // Load data from APIs
        function loadData() {
            // Load switches
            fetch('/api/switches')
                .then(r => r.json())
                .then(data => {
                    allSwitches = data.switches;  // Store globally for modal
                    document.getElementById('switch-stat').textContent = data.switches.length;

                    let html = '';
                    data.switches.forEach(sw => {
                        html += `<tr>
                            <td>${sw.dpid}</td>
                            <td>${sw.name}</td>
                            <td>${sw.hostname} (${sw.host})</td>
                            <td><span class="status-badge online">Connected</span></td>
                            <td>${sw.ports}</td>
                            <td>${sw.flows}</td>
                        </tr>`;
                    });
                    document.getElementById('switches-body').innerHTML = html;
                })
                .catch(e => {
                    document.getElementById('switches-body').innerHTML =
                        '<tr><td colspan="6" style="color: red;">Error loading switches</td></tr>';
                });

            // Load tunnels
            fetch('/api/tunnels')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('tunnel-stat').textContent = data.tunnels.length;

                    let html = '';
                    if (data.tunnels.length === 0) {
                        html = '<tr><td colspan="7" style="text-align: center; color: #7f8c8d;">No tunnels created yet. Click "Create Tunnel" to get started!</td></tr>';
                    } else {
                        data.tunnels.forEach(t => {
                            html += `<tr>
                                <td>${t.id}</td>
                                <td>${t.src_switch_name}@${t.src_host}</td>
                                <td>${t.dst_switch_name}@${t.dst_host}</td>
                                <td>${t.vni}</td>
                                <td>${t.src_vxlan_ip} ‚Üî ${t.dst_vxlan_ip}</td>
                                <td><span class="status-badge online">${t.status}</span></td>
                                <td><button class="btn-danger" onclick="deleteTunnel(${t.id})">Delete</button></td>
                            </tr>`;
                        });
                    }
                    document.getElementById('tunnels-body').innerHTML = html;
                })
                .catch(e => {
                    document.getElementById('tunnels-body').innerHTML =
                        '<tr><td colspan="7" style="color: red;">Error loading tunnels</td></tr>';
                });

            // Load hosts (full table)
            fetch('/api/hosts')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('host-stat').textContent = data.hosts.length;

                    let html = '';
                    if (data.hosts.length === 0) {
                        html = '<tr><td colspan="8" style="text-align: center; color: #7f8c8d;">No hosts. Click "Add Host" to get started!</td></tr>';
                    } else {
                        data.hosts.forEach(host => {
                            const isLocalhost = host.type === 'localhost';
                            const vxlanIp = host.vxlan_ip || host.ip;
                            const bridges = host.bridges ? host.bridges.join(', ') : '-';

                            let actions = '';
                            if (isLocalhost) {
                                actions = '<span style="color: #7f8c8d; font-size: 11px;">Local</span>';
                            } else {
                                actions = `
                                    <button class="btn" style="font-size: 10px; padding: 2px 6px;" onclick="detachHost(${host.id}, '${host.hostname}')" title="Detach (keep data)">üì¶ Detach</button>
                                    <button class="btn-danger" style="font-size: 10px; padding: 2px 6px;" onclick="forgetHost(${host.id}, '${host.hostname}')" title="Forget (delete)">üóëÔ∏è Forget</button>
                                `;
                            }

                            html += `<tr>
                                <td>${host.id}</td>
                                <td><strong>${host.hostname}</strong></td>
                                <td>${host.ip}</td>
                                <td>${vxlanIp !== host.ip ? vxlanIp : '<span style="color:#7f8c8d">same</span>'}</td>
                                <td>${isLocalhost ? '<span style="color:#3498db">localhost</span>' : 'remote'}</td>
                                <td>${host.ovs_version || '-'}</td>
                                <td>${bridges}</td>
                                <td>${actions}</td>
                            </tr>`;
                        });
                    }
                    document.getElementById('hosts-body').innerHTML = html;
                })
                .catch(e => {
                    document.getElementById('host-stat').textContent = '?';
                    document.getElementById('hosts-body').innerHTML =
                        '<tr><td colspan="8" style="color: red;">Error loading hosts</td></tr>';
                });

            // Load detached hosts
            fetch('/api/hosts/detached')
                .then(r => r.json())
                .then(data => {
                    const section = document.getElementById('detached-hosts-section');
                    const tbody = document.getElementById('detached-hosts-body');

                    if (data.detached_hosts && data.detached_hosts.length > 0) {
                        section.style.display = 'block';
                        let html = '';
                        data.detached_hosts.forEach(host => {
                            const bridges = host.last_bridges ? host.last_bridges.join(', ') : '-';
                            const detachedAt = host.detached_at ? new Date(host.detached_at).toLocaleString() : '-';

                            html += `<tr>
                                <td>${host.id}</td>
                                <td>${host.hostname || '-'}</td>
                                <td>${host.ip || '-'}</td>
                                <td>${bridges}</td>
                                <td style="font-size: 11px;">${detachedAt}</td>
                                <td>
                                    <button class="btn" style="font-size: 10px; padding: 2px 6px; background: #27ae60;" onclick="reattachHost(${host.id}, '${host.hostname}')" title="Re-attach host">üîÑ Re-attach</button>
                                    <button class="btn-danger" style="font-size: 10px; padding: 2px 6px;" onclick="forgetHost(${host.id}, '${host.hostname}')" title="Permanently delete">üóëÔ∏è Delete</button>
                                </td>
                            </tr>`;
                        });
                        tbody.innerHTML = html;
                    } else {
                        section.style.display = 'none';
                    }
                })
                .catch(e => {
                    document.getElementById('detached-hosts-section').style.display = 'none';
                });

            // Load networks
            fetch('/api/networks')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('network-stat').textContent = data.networks.length;

                    let html = '';
                    if (data.networks.length === 0) {
                        html = '<tr><td colspan="9" style="text-align: center; color: #7f8c8d;">No networks created yet. Click "Create Network" to get started!</td></tr>';
                    } else {
                        data.networks.forEach(net => {
                            // DHCP status display
                            let dhcpStatus = '';
                            if (net.dhcp_enabled) {
                                dhcpStatus = `<span class="status-badge online" style="font-size: 10px;">ON</span>
                                    <br><small>${net.dhcp_range || ''}</small>
                                    <br><button class="btn" style="font-size: 10px; padding: 2px 6px; margin-top: 4px;" onclick="showDHCPLeases(${net.id})">Leases</button>
                                    <button class="btn-danger" style="font-size: 10px; padding: 2px 6px;" onclick="disableDHCP(${net.id})">Off</button>`;
                            } else {
                                const hasSubnet = net.subnet && net.gateway;
                                if (hasSubnet) {
                                    dhcpStatus = `<span style="color: #7f8c8d; font-size: 11px;">Disabled</span>
                                        <br><button class="btn" style="font-size: 10px; padding: 2px 6px; margin-top: 4px;" onclick="showEnableDHCPModal(${net.id}, '${net.name}', '${net.subnet}', '${net.gateway}')">Enable</button>`;
                                } else {
                                    dhcpStatus = `<span style="color: #95a5a6; font-size: 11px;">N/A</span>
                                        <br><small style="color: #bdc3c7;">Need subnet</small>`;
                                }
                            }

                            html += `<tr>
                                <td>${net.id}</td>
                                <td><strong>${net.name}</strong></td>
                                <td>${net.vni}</td>
                                <td>${net.subnet || '-'}</td>
                                <td>${net.gateway || '-'}</td>
                                <td>${dhcpStatus}</td>
                                <td>${net.switch_names ? net.switch_names.join(', ') : net.switches.length + ' switches'}</td>
                                <td>${net.tunnel_count}</td>
                                <td><button class="btn-danger" onclick="deleteNetwork(${net.id})">Delete</button></td>
                            </tr>`;
                        });
                    }
                    document.getElementById('networks-body').innerHTML = html;
                })
                .catch(e => {
                    document.getElementById('networks-body').innerHTML =
                        '<tr><td colspan="9" style="color: red;">Error loading networks</td></tr>';
                });

            // Update uptime
            fetch('/api/status')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('uptime').textContent = data.uptime;
                });
        }

        function refreshData() {
            loadData();
            alert('Data refreshed!');
        }

        // Auto-refresh every 30 seconds
        setInterval(loadData, 30000);

        // ============ TOPOLOGY VISUALIZATION (D3.js) ============

        // Global topology state
        let topoSimulation = null;
        let topoSvg = null;
        let topoG = null;
        let topoAnimated = true;
        let topoCurrentView = 'all';
        let topoData = { nodes: [], links: [] };
        let topoHosts = [];
        let topoTunnels = [];
        let topoSwitches = [];

        // VNI color palette - vibrant gradients
        const vniColors = [
            { start: '#00d2ff', end: '#3a7bd5' },  // Blue
            { start: '#f857a6', end: '#ff5858' },  // Pink-Red
            { start: '#11998e', end: '#38ef7d' },  // Green
            { start: '#fc4a1a', end: '#f7b733' },  // Orange
            { start: '#8E2DE2', end: '#4A00E0' },  // Purple
            { start: '#00c6ff', end: '#0072ff' },  // Light Blue
            { start: '#f093fb', end: '#f5576c' },  // Pink
            { start: '#4facfe', end: '#00f2fe' },  // Cyan
            { start: '#43e97b', end: '#38f9d7' },  // Mint
            { start: '#fa709a', end: '#fee140' },  // Sunset
        ];

        function getVNIColor(vni) {
            const index = vni % vniColors.length;
            return vniColors[index];
        }

        // Initialize topology visualization
        function initTopology() {
            const container = document.getElementById('topology-container');
            const width = container.clientWidth;
            const height = 500;

            // Clear existing
            d3.select('#topology-svg').selectAll('*').remove();

            topoSvg = d3.select('#topology-svg')
                .attr('width', width)
                .attr('height', height);

            // Add gradient definitions
            const defs = topoSvg.append('defs');

            // Host gradient
            const hostGrad = defs.append('linearGradient')
                .attr('id', 'hostGradient')
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '100%').attr('y2', '100%');
            hostGrad.append('stop').attr('offset', '0%').attr('stop-color', '#667eea');
            hostGrad.append('stop').attr('offset', '100%').attr('stop-color', '#764ba2');

            // Glow filter
            const glow = defs.append('filter')
                .attr('id', 'glow')
                .attr('x', '-50%').attr('y', '-50%')
                .attr('width', '200%').attr('height', '200%');
            glow.append('feGaussianBlur').attr('stdDeviation', '3').attr('result', 'coloredBlur');
            const feMerge = glow.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            // Create main group with zoom
            topoG = topoSvg.append('g').attr('class', 'topology-main');

            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.3, 3])
                .on('zoom', (event) => {
                    topoG.attr('transform', event.transform);
                });

            topoSvg.call(zoom);

            // Add grid pattern background
            const gridPattern = defs.append('pattern')
                .attr('id', 'grid')
                .attr('width', 40)
                .attr('height', 40)
                .attr('patternUnits', 'userSpaceOnUse');
            gridPattern.append('circle')
                .attr('cx', 20).attr('cy', 20).attr('r', 1)
                .attr('fill', 'rgba(255,255,255,0.05)');

            topoSvg.insert('rect', ':first-child')
                .attr('width', '100%')
                .attr('height', '100%')
                .attr('fill', 'url(#grid)');

            loadTopologyData();
        }

        // Load and process topology data
        function loadTopologyData() {
            Promise.all([
                fetch('/api/hosts').then(r => r.json()),
                fetch('/api/switches').then(r => r.json()),
                fetch('/api/tunnels').then(r => r.json())
            ]).then(([hostsData, switchesData, tunnelsData]) => {
                topoHosts = hostsData.hosts || [];
                topoSwitches = switchesData.switches || [];
                topoTunnels = tunnelsData.tunnels || [];

                processTopologyData();
                renderTopology();
                updateTopologyStats();
            }).catch(err => {
                console.error('Error loading topology data:', err);
            });
        }

        // Process raw data into D3 nodes and links
        function processTopologyData() {
            const nodes = [];
            const links = [];
            const hostPositions = {};

            // Create host nodes
            topoHosts.forEach((host, index) => {
                const hostId = `host-${host.id}`;
                nodes.push({
                    id: hostId,
                    type: 'host',
                    label: host.hostname,
                    ip: host.ip,
                    vxlanIp: host.vxlan_ip || host.ip,
                    data: host,
                    fx: null,
                    fy: null
                });
                hostPositions[host.id] = hostId;
            });

            // Create switch nodes
            topoSwitches.forEach((sw, index) => {
                const switchId = `switch-${sw.id}`;
                const hostId = hostPositions[sw.host_id];

                nodes.push({
                    id: switchId,
                    type: 'switch',
                    label: sw.name,
                    hostname: sw.hostname,
                    hostIp: sw.host,
                    dpid: sw.dpid,
                    ports: sw.ports,
                    parentHost: hostId,
                    data: sw
                });

                // Link switch to its host
                if (hostId) {
                    links.push({
                        source: hostId,
                        target: switchId,
                        type: 'host-switch',
                        vni: null
                    });
                }
            });

            // Create tunnel links between switches
            const switchMap = {};
            topoSwitches.forEach(sw => {
                // Map by hostname and switch name for lookup
                const key = `${sw.hostname}-${sw.name}`;
                switchMap[key] = `switch-${sw.id}`;
            });

            topoTunnels.forEach(tunnel => {
                const srcKey = `${tunnel.src_host}-${tunnel.src_switch_name}`;
                const dstKey = `${tunnel.dst_host}-${tunnel.dst_switch_name}`;
                const srcId = switchMap[srcKey];
                const dstId = switchMap[dstKey];

                if (srcId && dstId) {
                    links.push({
                        source: srcId,
                        target: dstId,
                        type: 'tunnel',
                        vni: tunnel.vni,
                        srcIp: tunnel.src_vxlan_ip,
                        dstIp: tunnel.dst_vxlan_ip,
                        status: tunnel.status,
                        data: tunnel
                    });
                }
            });

            topoData = { nodes, links };
        }

        // Render the topology with D3
        function renderTopology() {
            const container = document.getElementById('topology-container');
            const width = container.clientWidth;
            const height = 500;

            // Create gradient definitions for each unique VNI
            const defs = topoSvg.select('defs');
            const uniqueVnis = [...new Set(topoData.links.filter(l => l.type === 'tunnel').map(l => l.vni))];

            uniqueVnis.forEach(vni => {
                const color = getVNIColor(vni);
                const gradId = `vni-grad-${vni}`;

                if (!defs.select(`#${gradId}`).node()) {
                    const grad = defs.append('linearGradient')
                        .attr('id', gradId)
                        .attr('gradientUnits', 'userSpaceOnUse');
                    grad.append('stop').attr('offset', '0%').attr('stop-color', color.start);
                    grad.append('stop').attr('offset', '100%').attr('stop-color', color.end);
                }
            });

            // Update legend with VNI colors
            updateLegendVnis(uniqueVnis);

            // Create force simulation
            topoSimulation = d3.forceSimulation(topoData.nodes)
                .force('link', d3.forceLink(topoData.links).id(d => d.id).distance(d => {
                    if (d.type === 'host-switch') return 60;
                    return 200;
                }).strength(d => {
                    if (d.type === 'host-switch') return 1;
                    return 0.3;
                }))
                .force('charge', d3.forceManyBody().strength(d => {
                    if (d.type === 'host') return -400;
                    return -150;
                }))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => d.type === 'host' ? 60 : 30));

            // Draw links (tunnels first, then host-switch connections)
            const linkGroup = topoG.append('g').attr('class', 'links');

            // Tunnel links with gradients
            const tunnelLinks = linkGroup.selectAll('.tunnel-link-group')
                .data(topoData.links.filter(l => l.type === 'tunnel'))
                .enter()
                .append('g')
                .attr('class', 'tunnel-link-group');

            tunnelLinks.append('path')
                .attr('class', 'tunnel-link-bg');

            tunnelLinks.append('path')
                .attr('class', d => `tunnel-link ${topoAnimated ? 'tunnel-animated' : ''}`)
                .attr('stroke', d => `url(#vni-grad-${d.vni})`)
                .attr('stroke-width', 2.5)
                .on('mouseover', showTunnelTooltip)
                .on('mouseout', hideTooltip);

            // Host-switch links
            const hostSwitchLinks = linkGroup.selectAll('.host-switch-link')
                .data(topoData.links.filter(l => l.type === 'host-switch'))
                .enter()
                .append('line')
                .attr('class', 'host-switch-link')
                .attr('stroke', 'rgba(255,255,255,0.2)')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '4,4');

            // Draw nodes
            const nodeGroup = topoG.append('g').attr('class', 'nodes');

            // Host nodes (larger rectangles with rounded corners)
            const hostNodes = nodeGroup.selectAll('.node-host')
                .data(topoData.nodes.filter(n => n.type === 'host'))
                .enter()
                .append('g')
                .attr('class', 'node-host')
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded))
                .on('mouseover', showHostTooltip)
                .on('mouseout', hideTooltip);

            hostNodes.append('rect')
                .attr('width', 80)
                .attr('height', 50)
                .attr('x', -40)
                .attr('y', -25)
                .attr('rx', 8)
                .attr('fill', 'url(#hostGradient)')
                .attr('filter', 'url(#glow)');

            hostNodes.append('text')
                .attr('class', 'node-label')
                .attr('dy', -5)
                .text(d => d.label);

            hostNodes.append('text')
                .attr('class', 'node-label node-sublabel')
                .attr('dy', 10)
                .text(d => d.vxlanIp);

            // Server icon
            hostNodes.append('text')
                .attr('x', 28)
                .attr('y', -12)
                .attr('font-size', '14px')
                .text('üñ•Ô∏è');

            // Switch nodes (circles)
            const switchNodes = nodeGroup.selectAll('.node-switch')
                .data(topoData.nodes.filter(n => n.type === 'switch'))
                .enter()
                .append('g')
                .attr('class', 'node-switch')
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded))
                .on('mouseover', showSwitchTooltip)
                .on('mouseout', hideTooltip);

            switchNodes.append('circle')
                .attr('r', 20)
                .attr('fill', '#3498db')
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .attr('filter', 'url(#glow)');

            switchNodes.append('text')
                .attr('class', 'node-label')
                .attr('dy', 4)
                .text(d => d.label);

            // Update positions on tick
            topoSimulation.on('tick', () => {
                // Update tunnel links as curves
                tunnelLinks.selectAll('path').attr('d', d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy) * 0.8;
                    return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                });

                // Update host-switch links
                hostSwitchLinks
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                // Update nodes
                hostNodes.attr('transform', d => `translate(${d.x},${d.y})`);
                switchNodes.attr('transform', d => `translate(${d.x},${d.y})`);
            });
        }

        // Drag functions
        function dragStarted(event, d) {
            if (!event.active) topoSimulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) topoSimulation.alphaTarget(0);
            // Keep position fixed after drag
        }

        // Tooltip functions
        function showHostTooltip(event, d) {
            const tooltip = document.getElementById('topo-tooltip');
            tooltip.innerHTML = `
                <div class="tooltip-title">üñ•Ô∏è ${d.label}</div>
                <div class="tooltip-row"><span class="tooltip-label">Management IP:</span><span class="tooltip-value">${d.ip}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">VXLAN IP:</span><span class="tooltip-value">${d.vxlanIp}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">Type:</span><span class="tooltip-value">${d.data.type || 'remote'}</span></div>
            `;
            positionTooltip(event, tooltip);
        }

        function showSwitchTooltip(event, d) {
            const tooltip = document.getElementById('topo-tooltip');
            tooltip.innerHTML = `
                <div class="tooltip-title">üîå ${d.label}</div>
                <div class="tooltip-row"><span class="tooltip-label">Host:</span><span class="tooltip-value">${d.hostname}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">DPID:</span><span class="tooltip-value">${d.dpid}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">Ports:</span><span class="tooltip-value">${d.ports}</span></div>
            `;
            positionTooltip(event, tooltip);
        }

        function showTunnelTooltip(event, d) {
            const tooltip = document.getElementById('topo-tooltip');
            const color = getVNIColor(d.vni);
            tooltip.innerHTML = `
                <div class="tooltip-title" style="border-bottom-color: ${color.start};">üîó VXLAN Tunnel</div>
                <div class="tooltip-row"><span class="tooltip-label">VNI:</span><span class="tooltip-value" style="color: ${color.start};">${d.vni}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">Source:</span><span class="tooltip-value">${d.srcIp}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">Destination:</span><span class="tooltip-value">${d.dstIp}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">Status:</span><span class="tooltip-value" style="color: #2ecc71;">‚óè ${d.status}</span></div>
            `;
            positionTooltip(event, tooltip);
        }

        function positionTooltip(event, tooltip) {
            const container = document.getElementById('topology-container');
            const rect = container.getBoundingClientRect();
            let x = event.clientX - rect.left + 15;
            let y = event.clientY - rect.top + 15;

            // Keep tooltip in bounds
            if (x + 200 > rect.width) x = x - 220;
            if (y + 100 > rect.height) y = y - 120;

            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('topo-tooltip').classList.remove('visible');
        }

        // Update legend with VNI colors
        function updateLegendVnis(vnis) {
            const legend = document.getElementById('topology-legend');
            let html = `
                <div class="legend-title">Legend</div>
                <div class="legend-items">
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(135deg, #667eea, #764ba2);"></div>
                        <span>Host</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db; border-radius: 50%;"></div>
                        <span>Switch</span>
                    </div>
            `;

            // Add VNI colors (limit to 5 for space)
            const displayVnis = vnis.slice(0, 5);
            displayVnis.forEach(vni => {
                const color = getVNIColor(vni);
                html += `
                    <div class="legend-item">
                        <div class="legend-line" style="background: linear-gradient(90deg, ${color.start}, ${color.end});"></div>
                        <span>VNI ${vni}</span>
                    </div>
                `;
            });

            if (vnis.length > 5) {
                html += `<div class="legend-item"><span>+${vnis.length - 5} more</span></div>`;
            }

            html += '</div>';
            legend.innerHTML = html;
        }

        // Update stats
        function updateTopologyStats() {
            document.getElementById('topo-hosts').textContent = topoHosts.length;
            document.getElementById('topo-switches').textContent = topoSwitches.length;
            document.getElementById('topo-tunnels').textContent = topoTunnels.length;

            const uniqueVnis = [...new Set(topoTunnels.map(t => t.vni))];
            document.getElementById('topo-vnis').textContent = uniqueVnis.length;
        }

        // Control functions
        function toggleAnimation() {
            topoAnimated = !topoAnimated;
            const btn = document.getElementById('btn-animate');
            btn.textContent = topoAnimated ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';

            topoSvg.selectAll('.tunnel-link')
                .classed('tunnel-animated', topoAnimated);
        }

        function setTopologyView(view) {
            topoCurrentView = view;
            document.querySelectorAll('.topology-controls .topo-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('view-all').classList.add('active');
            // Future: Filter by VNI
        }

        function resetTopology() {
            // Release all fixed positions
            topoData.nodes.forEach(n => {
                n.fx = null;
                n.fy = null;
            });
            topoSimulation.alpha(1).restart();
        }

        function toggleFullscreen() {
            const container = document.getElementById('topology-container');
            if (container.style.height === '800px') {
                container.style.height = '';
                document.getElementById('topology-svg').setAttribute('height', '500');
            } else {
                container.style.height = '800px';
                document.getElementById('topology-svg').setAttribute('height', '800');
            }
            if (topoSimulation) {
                topoSimulation.force('center', d3.forceCenter(
                    container.clientWidth / 2,
                    parseInt(document.getElementById('topology-svg').getAttribute('height')) / 2
                ));
                topoSimulation.alpha(0.5).restart();
            }
        }

        // Refresh topology with latest data
        function refreshTopology() {
            loadTopologyData();
        }

        // Initialize topology when page loads
        setTimeout(initTopology, 1500);

        // Refresh topology when data refreshes
        const originalLoadData = loadData;
        loadData = function() {
            originalLoadData();
            setTimeout(refreshTopology, 500);
        };

        // ============ END TOPOLOGY VISUALIZATION ============
    </script>
</body>
</html>
